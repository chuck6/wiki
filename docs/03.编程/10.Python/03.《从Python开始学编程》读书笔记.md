---
title: 《从Python开始学编程》读书笔记
date: 2022-01-20 14:24:13
permalink: /pages/63a425/
categories:
  - 编程
  - Python
tags:
  - 
---



# 《从Python开始学编程》读书笔记

本书以Python为样本，不仅介绍了编程的基本概念，还着重讲解了编程语言的范式(面向过程、面向对象、面向函数)，并把编程语言的范式糅合在Python中。



## 先做键盘侠




## 运算符

### 数值运算

具体的算术如下：

``` python
>>> 1 + 9
>>> 1.3 - 4
>>> 3*5
>>> 4.5/1.5
>>>3**2            #乘方，即求3的二次方
>>>10%3            #求余数，就求10除以3的余数。结果为1
>>>"vamei say:" + "Hello World" #字符串加法运算，也就是把字符串进行连接
>>>"Vamei"*2       #结果为"VameiVamei"
```



### 逻辑运算

and 与 / or 或 /not 非



### 判断表达式

``` python
>>>1 == 1          # 相等
>>>8.0 != 8.0      # 不等于
>>>4 < 5           # <, 小于
>>>3 <= 3          # <=，小于或等于
>>>4 > 5           # >，大于
>>>4 >=0           # >=,大于等于
```



### 运算优先级

运算符的优先级高低如下所示：

``` python
乘方：**
乘除: *  /
加减: + -
判断: ==   >  >=  <  <=
逻辑: !  and  or
```



## 数据结构

### 变量的类型

python能自由改变变量类型的特征被称为**动态类型**。并不是所有语言都支持动态类型。

在**静态类型**的语言中，变量有事先说明好的类型。特定类型的数据必须存入特定类型的变量。

变量有int整型、浮点数float、字符串string、布尔值bool。

动态类型的语言看起来不需要说明类型，但其实是把区分类型的工作交给解释器。当改变变量的值的时候，python解释器会自动分辨出新数据的类型，再为数据开辟相应类型的内存空间。

Python解释器的贴心的服务让编程更加方便，但也把计算机的一部分能力用于支持动态类型上。这也是**Python的速度不如C语言等静态类型语言的一个原因**。

可以使用type()这一函数来查看变量的类型

``` python
var_integer = 10
print(type(var_integer))
```



### 序列

Python中的序列和词典，都是特殊类型的变量。能像一个容器一样，都是容器型变量，收纳多个数据。

序列是有顺序的数据集合，就好像一列排好队的士兵。序列包含的一个数据被称为序列的一个**元素**。序列可以包含一个或多个元素，也可以是完全没有任何元素的空序列。



#### 元组和列表

序列有两种，元组(tuple)和列表(list)。两者的主要区别在于，一旦建立，元组的各个元素不可再变更，而列表元素可以变更。

所以，元组看起来就像一种特殊的表，有固定的数据。

``` python
>>> example_tuple = (2, 1.3, "love", 5.6, False)  #一个元组，括号
>>> example_list = [True, 5, "smile"]             #一个列表，中括号
>>> example_list1 = [1, [3,4,5]]                  #列表中嵌套另一个列表
>>> type(example_tuple)                           #结果为'tuple'
>>> type(example_list)                            #结果为'list'
```



#### 序列下标

序列元素的位置索引称为**下标**，可以通过下标来找到序列中的对应的元素。

Python中序列的下标从0开始，即第一个元素的对应下标为0。

``` python
>>> example_tuple[0]          #显示序列example_tuple元组中第一个元素
>>> nest_list = [1,[3,4,5]]   #列表中嵌套另一个列表
>>> nest_list[1][2]           #显示的是第二个元素中，第二个元素是一个嵌套的列表，该嵌套列表中的第三个元素
```



元组一旦建立就不能改变，所以不能对元组的元素进行赋值操作。



#### 序列中范围引用

序列中可以通过范围引用，来找到多个元素。范围引用的基本样式是：

序列名[下限:上限:步长]

下限表示起始下标，上限表示结尾下标。在起始下标和结尾下标之间，按照步长的间隔来找到元素。默认的步长是1。

``` python
>>> example_tuple[:5]             # 从下标0到下标4，不包含下标5的元素
>>> example_tuple[2:]             # 从下标2到最后一个元素
>>> example_tuple[0:5:2]          # 下标为0，2，4的元素
>>> sliced =  example_tuple[2:0:-1] # 从下标2到下标1
>>> type(sliced)                  # 范围引用的结果还是一个元组
>>> example_tuple[-1]             # 序列最后一个元素
>>> example_tuple[-3]             # 序列倒数第三个元素
>>> example_tuple[1:-1]           # 序列的第二个到倒数第二个元素
```



### 词典

词典从很多方面都和序列中的列表比较相似。同样是一个可以容纳多个元素的容器。但是词典不是以位置来作为索引的。词典允许用自定义的方式来建立数据的索引。

词典包含多个**元素**，每个元素以逗号分隔。词典的元素包含两部分，键(key)和值(value)。键是数据的索引，值是数据本身。

词典的元素可以通过键来引用。

词典不具备序列那样的连续有序性，所以适用于存储结构松散的一组数据。

大部分场景中，我们都是用字符串来作为词典的键。其他类型，例如数字和布尔值，也可以作为词典的键值。

``` python
>>> example_dict = {"tom":11, "sam":57, "lily":100}
>>> type(example_dict)                                    #结果为'dict'
>>> example_dict["tom"]                                   #结果为11，引用
>>> example_dict["tom"] = 30                              #修改一个元素值
>>> example_dict["lilei"] = 99                            #添加一个元素值
>>> example_dict                                          #查看所有的元素值
```



## IF

### if结构

关键字if和else分别有隶属于它们的一行或多行代码，从属代码的开头会有四个空格的缩进。程序最终会根据if后的条件是否成立，选择是执行if的从属代码，还是执行else的从属代码。if结构在程序中实现了分支。

else也并非必须的，可以写只有if的程序；没有else，实际上与空的else等价。如果if后的条件不成立，那么计算机什么都不用执行。

``` python
total = 980000
if total > 500000:
    print ("总价超过了50万")
    transaction_rate = 0.01
else:
    print ("总价不超过50W")
    transaction_rate = 0.02
    
total = 980000
if total > 500000:
    print ("总价超过50W")
```



### if结构中的缩进

用缩进来表明代码的从属关系，是Python的特色。

在python中，去掉了if条件后面i>0周围的括号，去除了每个语句句尾的分号，表示块的花括号也消失了。多出来了if...之后的:(冒号)，还有就是从属代码前面有四个空格的缩进。通过缩进，Python识别出这两个语句是隶属于if的。为了区分隶属关系，python中的缩进是强制的。



### if的嵌套与elif

elif的定义：

我们可以在if和else之间增加多个elif，从而给程序开出更多的分支。

elif说白了就是在if后面的增加的，另外的多个条件，多个选择的分支。

在出现if、elif和else三个块的代码中。Python先检测if的条件，如果发现if的条件为假，则跳过隶属于if的程序块，检测elif的条件；如果elif的条件还是假的，则执行else块。程序会根据跳进，只执行三个分支中的一个。

``` python
if i > 0:
    i = i + 1
elif i == 0:
    i = i*10
else:
    i = i - 1
```



if的嵌套：

意思是一个if结构中嵌套了另一个if结构，意思是进入一个选择分支后，又进入了一个选择分支。同样涉及到if的从属语句，要和if空4个空格的缩进。

在进行完第一个if判断后，如果条件成立，那么程序依次运行，会遇到第二个if结构。程序将继续根据条件选择并决定是否执行。

``` python
if i > 1:
    print("good")
    if i > 2:
        print("better")
```



## 循环

循环用于重复执行一些代码块，在Python中，循环有for和while两种。

### for循环

属于循环结构的、需要重复的程序，也要同if结构一样，要被缩进四个空格。

``` python
for a in [3,4.4,"life"]:
    print(a)
```



#### for循环基本用法一

for的一个基本用法是在in后面跟一个序列，序列中元素的个数决定了循环重复的次数。

从序列中取出元素，再赋予给一个变量并在隶属程序中使用。

``` python
for 元素 in 序列:
    statement
```



#### for循环基本用法二

有时候，我只是想简单重复特定的次数，不想建立序列，我们可以使用Python提供的range()函数,range中间的数字就是说明了需要重复的次数。需要注意的是，range()提供的计数也是从0开始的，和序列列表中的下标一样。

``` python
for i in range(5):
    print(i, "Hello World!")
```



### while循环

while后面紧跟着一个条件。如果条件为真，则while会不停地循环执行隶属于它的语句。只有条件为假的时候，程序才会停止。

``` python
i = 0
while i < 10:
    print(i)
    i = i + 1
```



### 跳出或终止

循环结构还提供了两个有用的语句，可以在循环结构内部使用，用于跳出或终止循环。

continue用于跳出循环的这一次循环，进行下一次的循环操作。

break则是停止执行整个循环。

``` python
for i in range(10):
    if i == 2:
        continue
    print(i)
    
for i in range(10):
    if i == 2:
        break
    print(i)
```



## 代码规范

由于强制缩进的规定，Python代码看起来相对比较整齐。

Python官方文档中提供了一套代码规范，即PEP8。

1. 在下列运算符的前后各保留一个空格

   ``` python
   = + - > == >= < <= and or not
   ```

2. 下列运算符的前后不用保留空格

   ``` python
   * / **
   ```

3. 如果有多行赋值，那么将上下的赋值号=对齐

   ``` python
   num      = 1
   secNum   = 2
   ```

4. 变量的所有字母小写，单词之间用下画线连接

   ``` python
   example_number = 10
   ```
   
5. 类的命名采用首字母大写的英文单词。如果由多个单词连接而成，则每个单词的首字母都大写。单词之间不出现下画线。

6. 对象名、属性名和方法名，全部用小写字母。单词之间用下画线连接。



## 过程大于结果

这一章我们将完成面向过程的编程范式的学习。

在这一章中，我们将看到其他面向过程的封装方法，即函数和模块。**函数和模块把成块的指令封装成可以重复调用的代码块**，并借着函数名和模块名整理出一套接口，方便未来调用。



## 函数

### 函数是什么

从数学上来看，函数代表了集合之间的对应关系。例如定义域集合和值域集合之间的定义关系。

从程序来看，**函数是一种语法结构**。它把一些指令封装在一起，形成一个组合拳。一旦定义好了函数，我们就可以通过对函数的调用，来启动这套组合拳。**函数是对封装理念的实践**。输入数据被称为参数，参数能影响函数的行为。



### 定义函数

在python中使用def这个关键字来定义函数，关键字def后面跟着的是函数的名字。

在函数名后面，还有一个括号，用来说明函数有哪些参数，参数可以有多个，也可以完全没有。

函数中定义的参数是一个形式代表，并非真正数据，所以又称为形参。

根据Python语法规定，即使没有输入数据，函数后面的括号也要保留。

括号结束后，第一行的末尾，有一个冒号，后面的代码和之前的一样，也要有4个空格缩进。

最后一句return，关键字return用于说明函数的返回值，即函数的输出数据。

函数执行到return时就会结束，不管它后面是否还有其他函数定义语句。

return启动了中止函数和制定返回值的功能。

在Python的语法中，return并不是必需的。如果没有return，或者return后面没有返回值，则函数将返回None。

None是Python中的空数据，用来表示什么都没有。关键字return也返回多个值。

``` python
def square_sum(a,b):
    a = a**2
    b = b**2
    c = a + b
    return c
```



### 调用函数

使用函数的过程叫做调用函数。

在函数调用时出现的参数称为实参。

函数调用的写法，其实与函数定义第一行def后面的内容相仿。只不过在调用函数的时候，我们把真实的数据填入到括号中，作为参数传递给函数。

除具体的数据表达式外，参数还可以是程序中已经存在的变量。

``` python
a = 5
b = 6
x = square_sum(a, b)
print(x)
```



### 函数文档

在定义函数的时候，要加上清晰的说明文档，说明函数的功能和用法分别是什么。

查看函数文档，可以用help()来查看。注意的是这个多行注释同样是有缩进的。

``` python
def square_sum(a,b):
    """ return the square sum of two arguments"""
    a = a**2
    b = b**2
    c = a + b
    return c
```



## 参数传递

把数据用参数的形式输入到函数，被称为参数传递。

在定义函数的时候就说明了函数的个数，这是基本传参。

如果在定义函数的时候，我们并不知道参数的个数；有时需要在程序运行的时候才能知道参数的个数；有时是希望函数定义的更加松散，以便于函数能运用于不同形式的调用。这个时候会用到包裹(packing)传参的方式来进行参数传递。



### 基本传参

#### 位置确定参数

有多个参数，在调用函数的时候，Python会根据位置来确定数据对应哪个参数。确定实参与形参的对应关系。

``` python
def print_arguments(a, b, c):
    """print arguments according to their sequence"""
    print(a, b, c)
    
print_arguments(1, 3, 5)
```



#### 关键字传参

根据位置传参比较死板，可以利用关键字(keyword)的方式来传递参数。

在定义函数的时候，给形参一个符号标记，即参数名。

关键字传递是根据参数名来让数据与符号对应上。

``` python
print_arguments(c=5, b=3, a=1)
```



位置传递与关键字传递混用，即一部分的参数传递根据位置，另一部分根据参数名。

在调用函数的时候，所有的位置参数都要出现在关键字参数之前。

如果位置参数放在关键字参数后面，python会报错。

``` python
print_arguments(1, c=5, b=3)
```



#### 形参默认值

在函数定义的时候，可以设置某些形参的默认值。如果我们在调用的时候不提供这些形参的具体数据，那么我们将采用定义时的默认值。

``` python
def f(a, b, c=10):
    return a + b + c      

print(f(3,2,1))           # 参数c取传入的1，结果打印6
print(f(3,2))             # 参数c取默认值10。结果打印15
```



### 包裹传参

所谓"包裹传参"是指，我们在定义函数的函数的时候，我们并不知道参数的个数，需要在程序运行时才能知道。所以我们在定义函数的函数更加松散，以便于函数能运用于不同形式的调用。

包裹传参也有位置和关键字两种形式。



#### 元组方式

在调用package_position()的时候，所有的数据都根据先后顺序，收集到一个元组。

在函数内部，我们可以通过元组来读取传入的数据。

在定义package_position()时要在元组名all_arguments前加*号，来表示使用的元组方式的包裹传递参数的方式。

``` python
def package_position(*all_arguments):
    print(type(all_arguments))
    print(all_arguments)

package_position(1,4,6)
package_position(5,6,7,8,9)
```



#### 词典方式

下面包裹关键字传递的例子中，参数传递方法把传入的数据收集为一个词典。

每个关键字形式的参数调用，都会成为字典的一个元素。

参数名成为元素的键，而数据成为元素的值。

字典all_arguments收集了所有的参数，把数据传递给函数使用。我们在all_arguments前加上**，表示all_arguments的参数传递使用的包裹关键字字典的方式。

``` python
def package_keyword(**all_arguments):
    print(type(all_arguments))
    print(all_arguments)
    
package_keyword(a=1, b=9)
package_keyword(m=2, n=1, c=11)
```



#### 多种传参方式混用

包裹位置传参和包括关键字传参可以混合使用。

包裹传参和基本传参也可以混合使用。它们出现的先后顺序是：位置->关键字->包裹位置->包裹关键字。



### 解包裹

之前的包裹传参，是用于参数定义的阶段。主要的应用场景是：我们不确定后续有多个参数要传入，只能定义为元组或字典的方式的函数，后续调用的时候，不用考虑传入多少个参数了。

解包裹并不是包裹的相反操作，解包裹的意思是，调用函数的时候，传入的参数并不是一个直接的传递的这个参数值，而是一个元组(用*表示)，或是一个字典(用\*\*表示)，来提醒Python把对应的元组或字典去拆成一个一个对应的元素到具体的参数中去。

解包裹用于函数调用。在调用函数的时候，几种参数的传递方式也可以混合。依然是相同的基本原则：位置 -> 关键字 -> 位置解包裹 -> 关键字解包裹

``` python
def unpackage(a,b,c):
    print(a,b,c)

args = (1,3,4)
unpackage(*args)       #结果为1 3 4

args = {"a":1,"b":2,"c":3}
unpackage(**args)      # 打印1、2、3
```



## 递归

### 为什么要用递归

有些应用场景，利用递归的算法特性，会使得逻辑更清晰。

例如，如何比对一个json串的时候，可能一个key value值里面又包含一个key value值，层层嵌套。



### 什么是递归

递归是函数调用其自身的操作。



#### 数学归纳法

递归的思想源于数学归纳法，常用于证明命题在自然数范围内成立。

数学归纳法本身非常简单。如果我们想要证明某个命题对于自然数n成立，那么：

第一步，证明命题对于n=1成立。

第二步，**假设**命题对于n成立，n为任意自然数，则证明在此假设下，命题对于n+1成立。



### 如何写递归

递归的写法，要注意三个方面：初始条件、终止条件及衔接。从下面的列子来看衔接就是函数gasssian_sum(n)与gasssian_sum(n-1)的关系。

为了保证计算机不陷入死循环，递归要求程序有一个能够达到的终止条件。还有递归的关键是说明衔接的两个步骤之间的衔接条件。

设计递归程序的时候，我们从最终结果入手，要想求得gasssian_sum(100)，计算机会把这个计算拆解为求得gasssian_sum(99)的运算，以及gasssian_sum(99)加上100的运算。以此类推，直到拆解为gasssian_sum(1)的运算，就触发终止条件。

``` python
def gasssian_sum(n):
    if n == 1:
        return 1
    else:
        return n + gasssian_sum(n-1)

print(gasssian_sum(100))
```



### 函数栈

程序中的递归需要用到栈这一数据结构。

栈最显著的特征是"后进先出"(LIFO)。**栈中的每一个元素，被称为一个帧(frame)**。栈只支持两个操作：pop和push。栈用弹出(pop)操作来取出栈顶元素，用推入(push)操作将一个新的元素存入栈顶。

上面的例子中，为了计算gasssian_sum(100)，我们需要先暂停gasssian_sum(100)，开始gasssian_sum(99)的计算。为了计算gasssian_sum(99)，需要先暂停gasssian_sum(99)，调用gasssian_sum(98) ......。在触发终止条件前，会有很多次为完成的函数调用。每次函数调用时，我们在栈中推入一个新的帧，用来保存这次函数调用的相关信息。栈不断增长，知道计算出gasssian_sum(1)后，我们又会恢复计算gasssian_sum(2)、gasssian_sum(3), ......。由于栈"后进先出"的特点，所以每次只需要弹出栈的帧，就正好是我们所需要的gasssian_sum(2)、gasssian_sum(3)......直到弹出藏在最底层的帧gasssian_sum(100)。

所以，程序运行的过程，可以看做是一个先增长栈后消灭栈的过程。每次函数调用，都伴随着一个帧入栈。如果函数内部还有函数调用，那么又会多一个帧入栈。当函数返回时，相应的帧会出栈。等到程序的最后，栈清空，程序就完成了。

要注意栈溢出(stack overflow)，由于直到栈底才会去释放之前栈的空间，需要消耗很多的栈内存。



### 变量的作用域

1. python寻找变量的范围不止是当前的函数帧(当前函数内的变量)，它还会寻找函数外部，也就是Python主程序中定义的变量。

2. 当主程序中已经有一个变量，函数调用内部可以通过赋值的方式再创建了一个同名变量。函数会优先使用自己函数帧中的那个变量。这个时候，函数内部使用的变量的操作，不会影响到外部的那个同名变量。

3. 函数的参数与函数内部变量类似。可以把参数理解为函数内部的变量。在函数调用的时候，会把数据赋值给这些变量。等到函数返回的时候，这些参数相关的变量会被清空。
4. 但是将一个列表传递给函数，作为函数的参数的时候。在对函数进行操作后，函数外部的列表会发生变化。也就是说参数是一个数据容器的时候，函数内外部只存在一个数据容器，所以对函数内部对该数据容器的操作，会影响到函数外部。**对于数据容器，函数内部的更改会影响到外部**

``` python
info = "hello"
def external_var():
    info = "python"
    print(info)              # 结果为python
external_var()
print(info)                  # 结果还是为hello

b = [1,2,3]
def change_list(b):
    b[0] = b[0] + 1
    return b

print(change_list(b))       # 打印[2,2,3]
print(b)                    # 打印[2,2,3],已经改变了外部的list
```



## 模块

### 为什么要有模块

通过模块，我们可以调用其他文件中的函数。而引入(import)模块，就是为了在新的程序中重复利用已有的Python程序。



### 什么是模块

对于面向过程语言来说，模块是比函数更高一层的封装模式。程序可以以文件为单位实现复用。

在Python中，一个.py文件就构成一个模块。



### 如何使用模块

调用模块中的函数：

先写一个first.py文件，里面定义了一个laugh()的函数；然后再在同一个目录下写一个second.py文件，在这个python程序文件中引入first模块中的laugh函数；然后就可以在first模块中调用laugh函数了。

first.py文件如下：

``` python
def laugh():
    print("hahaha")
```

second.py文件如下：

``` python
from first import laugh
for i in range(10):
    laugh()
```



调用模块中的变量：

除了函数，我们还可以引入其他文件中包含的数据。

比如我们在module_var.py中有如下变量，我们在import_demo.py中，引入了这一变量：

module_var.py文件如下：

``` python
text = "Hello!"
```



import_demo.py中，我们引入这一变量：

``` python
from module_var import text
print(text)       #打印"Hello!"
```



### 搜索路径

Python寻找相应的模块，有着自己的查找路径：

1. Python会自动在当前文件夹下搜索它想要引入的模块。
2. 查找标准库的安装路径。
3. 操作系统环境变量PYTHONPATH所包含的路径。



## 异常处理

### 异常分类

1. 语法错误

   这类错误，是Python在没有运行代码的时候就发现了这类语法错误。例如，for循环中没有冒号。

2. 运行时错误

   只有在Python编译器运行的时候，才会发现的错误，被称为**运行时错误**。由于Python是动态语言，许多操作必须在运行时才会执行，比如确定变量的类型等等。因此，Python要比静态语言更容易产生运行时错误。

3. 语义错误

   还有一种错误，叫做**语义错误**。编译器认为你的程序没有问题，可以正常运行。但是当检查程序的时候，却发现程序并非我们想要的结果。这种错误最为隐蔽，也最难纠正。



### 异常处理

#### 为什么需要异常处理

对于运行时可能产生的错误，我们可以提前在程序中处理。

这样做有两个可能的目的：一个是让程序中止前进行更多的操作，比如提供更多的关于错误的信息。另一个则是让程序在犯错后依然能运行下去。

异常处理还可以提高程序的容错性。



#### 异常的基本结构

异常处理完整的语法形式为：

``` python
try:
    ...
except exception1:
    ...
except exception2:
else:
    ...
finally:
    ...
```

如果try中有异常发生时，将执行异常的归属，执行except。

异常层层比较，看是否是exception1、exception2 ...... 直到找到其归属，执行相应的except中的语句。

如果try中没有异常，那么except部分将跳过，执行else中的语句。

finally是无论是否有异常，最后都要做的一些事情。



#### 所有异常都捕获

如果except后面没有任何参数，那么表示所有的exception都交给这段程序处理：

``` python
while True:
    inputStr = input("Please input a number:")
    try:
        num = float(inputStr)
        print("Input number:", num)
        print("result:", 10/num)
    except:
        print("Something Wrong. Try Again.")
```



#### 子程序上抛异常至主程序

如果子程序无法将异常交给合适的对象，那么异常将继续向上层抛出，直到被捕捉或者造成主程序报错。比如下面的程序，子程序的try...except...结构无法处理相应的除以0的错误，所以错误被抛给上层的主程序。

``` python
def test_func():
    try:
        m = 1/0
    except ValueError:
        print("Catch ValueError in the sub-function")

try:
    test_func()
except ZeroDivisionError:
    print("Catch error in the main program")
```



#### 主动抛异常

使用raise关键字，我们也可以在程序中主动抛出异常。

``` python
raise ZeroDivisioError()
```



## 朝思暮想是对象

为什么要有面向对象？

在科学实践过程中，发现传统的面向过程的方法的编程方式无法去模拟真实世界中的个体。

面向对象的出现就是为了解决上述的困难，通过类和对象这两种语法结构，加强了程序模拟真实世界的能力。而"模拟"，正是面向对象编程的核心。

Python的一条哲学理念是"一切皆对象"。



## 类

### 什么是类

和我们认识的日常生活中的"类"的概念差不多。在日常生活中，我们把相近的东西归为一类，而且给这个类起一个名字。比如鸟类、鱼类等等。



### 如何定义类

定义类的时候，我们使用class关键字。类的名字的括号里面有一个关键字object，也就是"东西"的意思，即某一个个体。我们把个体称为对象。

在下面的例子中，我们定义了两个量，一个用于说明鸟类有羽毛，另一个用于说明鸟类的繁殖方式，这两个量称为类的属性。

``` python
class Bird(object):
    feather = True
    reproduction = "egg"
```



### 定义类的方法

除了用数据性的属性来分辨类别外，有时也会根据这类东西能做什么事情来区分。比如，鸟会移动。

这样的一些"行为"属性称为方法。

Python中，一般通过在类的内部定义函数来说明方法。

在下面的例子中，我们给鸟类新增了一个方法属性，表示鸟叫的方法chirp()。这个方法chirp()看起来很像一个函数。它的第一个参数是self，是为了在方法内部引用对象自身。无论该参数是否用到，方法的第一个参数必须是用于指代对象自身的self。剩下的sound是为了满足我们的需求设计的，代表了鸟叫的内容。方法chirp()会把sound打印出来。

``` python
class Bird(object):
    feather = True
    reproduction = "egg"
    def chirp(self, sound):
        print(sound)
```



## 对象

### 什么是对象

对象是一个个体，它是某一类的实例化。调用类，我们可以创造出这个类下面的一个对象。

```summer = Bird()```



### 展示对象的属性和方法

初始化完一个对象后，这个对象就有了这个类的属性和方法。

对于属性的引用，我们可以通过对象.属性的形式来实现。

```print(summer.reproduction)    #打印'egg'```

对于方法的调用，我们可以让该对象执行鸟类允许的动作。

```summer.chirp("jijijij")    #打印'jijijij'```

> 注意，在调用方法的时候，我们只传递了一个参数，也就是"jijijij"。这是方法与函数有所区别的地方。尽管我们在定义类的方法的时候，必须加上这个self参数，但是self只用能在类定义的内部，所以在调用方法的时候不需要对self传入参数了。



### 定义对象的个性属性

每个对象个体，除了拥有共性的类属性外，还需要用于说明个性的对象属性。



#### self配置个性对象属性

这个时候，我们可以在类中，通过self来操作对象的属性。

下面的例子中，我们在Bird类中，定义了一个set_color的方法，在这个方法中，我们通过self参数设定了对象的属性color。

和**对象.类属性**方式一样，我们能通过**对象.对象属性**的方式来操作对象属性。由于对象属性依赖于self，我们必须在某个方法内部才能操作类属性。因此，**对象属性没办法像类属性一样，在类下方直接赋初值**。

``` python
class Bird(object):
    def chirp(self, sound):
        print(sound)
    def set_color(self, color):
        self.color = color

summer = Bird()
summer.set_color("yellow")
print(summer.color)               # 打印'yellow'
```



#### \_init\_()方法初始化对象属性

上面是自己在类里面定义一个方法来满足，对象的个性化属性。

这里是利用Python自带的初始化对象属性的办法，这是特殊方法。名字很特别，前后有两个下划线。比如\_init\_()、\_add\_()、\_dict\_()等。对于类中的\_init\_()方法，Python会在**每次创建对象时自动调用**。和上面的方式不同的地方，上面需要手动调用。

``` python
class Bird(object):
    def __init__(self, sound):
        self.sound = sound
        print("my sound is:", sound)
    def chirp(self):
        print(self.sound)

summer = Bird("ji")
summer.chirp()
```



#### self调用类中其他方法

这里只是描述了self的另外一种功能，也就是说除了上面两种可以通过self自定义个性化的对象属性，还可以利用self实现在一个方法内部调用同一类的其他方法。

``` python
class Bird(object):
    def chirp(self, sound):
        print(sound)
    
    def chirp_repeat(self, sound, n):
        for i in range(n):
            self.chirp(sound)
```



## 子类

### 什么是子类

为了更为确切的用程序语言的方式来模拟现实世界，出现了子类的数据结构。

通过子类继承父类的方式，很减少程序中的重复信息和重复语句。继承提高了程序的可重复使用性。

类别本身还可以进一步细分为子类。例如，鸟类可以进一步分为鸡、天鹅等。在面向对象的编程中，我们通过子类**继承**父类的方式来表达这个概念。

在下面的案例中，我们定义了一个鸡类，和一个天鹅类，它们都继承来着鸟类这个父类。鸡类和天鹅类也就同时拥有鸟类所有定义的数据性属性和方法性的属性。

需要注意的是，在定义子类的时候，子类名字后面的括号里面，不在是object，而是父类的名字。

最基础的情况，是类定义的括号中是object。类object其实是Python中的一个内置类。它充当了所有类的祖先。

``` python
class Bird(object):
    feather = True
    reproduction = "egg"
    def chirp(self, sound):
        print(sound)

class Chicken(Bird):
    how_to_move = "walk"
    edible = True

class Swan(Bird):
    how_to_move = 'swim'
    edible = False

summer = Chicken()
print(summer.feather)                   # 打印True
summer.chirp("ji")                      # 打印'ji'
```



## 属性覆盖

我们可以在子类中替换父类已经存在了的属性。

通过对方法的覆盖，我们可以改变子类的行为。

在下面的案例中，鸡类是鸟类的子类。在鸡类中，我们同样定义了一个chirp()方法，这个方法在鸟类中也是有定义的。

调用鸡类中的这个chirp()方法来看，鸡类会调用自身定义的chirp()方法，而不是父类中的chirp()方法。从效果上来看，这就好像是父类中的方法chirp()被子类中的同名属性覆盖(override)了一样。

``` python
class Bird(object):
    def chirp(self):
        print("make sound")

class Chicken(Bird):
    def chirp(self):
        print("ji")

bird = Bird()
bird.chirp()            # 打印'make sound'

summer = Chicken()
summer.chirp()          #打印'ji'
```



### 子类中调用父类中被覆盖的方法

上面的案例中，我们可以通过对方法的覆盖，可以彻底地改变子类的行为。但有时候，**子类的行为是父类行为的拓展**。这个时候，**我们可以通过super关键字在子类中调用父类中被覆盖的方法**。

案例中，在鸡类的chirp()方法中，使用了super。这个是一个内置类，能产生一个指代父类的对象。通过super，我们在子类的同名方法中调用了父类的方法。这样，子类的方法既能执行父类中相关操作，又能定义属于自己的额外操作。

``` python
class Bird(object):
    def chirp(self):
        print("make sound")

class Chicken(Bird):
    def chirp(self):
        super().chirp()      #在子类的同名方法中调用了父类的同名方法
        print("ji")

bird = Bird()
bird.chirp()                # 打印"make sound"

summer = Chicken()
summer.chirp()              # 打印"make sound"和"ji"
```



## 回头再看对象

在对对象的基本概念了解后，我们在回头看看了解下之前我们已经熟悉列表、元组与字符串、词典、循环、函数。

在Python中，一切皆对象。我们要以面向对象的思维，再次来思考学习。



### 列表对象

#### 什么是列表对象?

我们在描述一个对象的时候，先考虑一下它所从属的类。list类，类是模拟现实世界的数据结构。它有自定义的静态的属性，和动态的可调用的方法。当我们新建了一个list的时候，实际上是在创建了list类的一个对象。



#### 创建list对象

``` python
a = [1,2,5,3,5]
type(a)
```

从新建的一个list的过程来看，实际上我们是创建了list类的一个对象。list类是Python自带的，已经提前定义好的，被称为内置类。



#### list类的属性和方法

1. 利用函数dir()来查询一个类或对象的所有属性。```dir(list)```

2. 利用函数help()来查询类的说明文档。```help(list)```

3. 调用list类中的count方法

   ``` python
   a = [1,2,3,5,9.0,"Good",-1,True,False,"Bye"]
   a.count(5)
   ```

4. 调用list类中的index方法

   ```a.index(3)```  查询元素3第一次出现时的下标

5. 调用list类中的append方法来添加一个新元素

   ```a.append(6)```  在列表的最后增添一个新元素6

6. 调用list类中的sort方法来排序

   ```a.sort()``` 

7. 调用list类中的reverse方法来颠倒次序

   ```a.reverse()```

8. 调用list类中的pop方法去除最后一个元素

   ```a.pop()```   去除最后一个元素，并将该元素返回

9. 调用list类中的remove方法去除第一次出现的某个元素

   ```a.remove(2)```  去除第一次出现的元素2

10. 调用list类中的insert方法来插入指定位置的元素

    ```a.insert(0,9)```   在下标为0的位置插入9

11. 调用list类中的clear方法来清空列表

    ```a.clear()```    清空列表



### 元组与字符串对象

#### 元组对象

元组与列表一样，都是序列。但是元组不能变更内容。所以，元组只能进行查询操作，不能进行修改操作。

``` python
a = (1,3,5)
a.count(5)     #计数，看总共有多少个元素5
a.index(3)     #查询元素3第一次出现时的小标
```



#### 字符串对象

字符串是特殊的元组，因此可以执行元组的方法。

尽管字符串是元组的一种，但是字符串有一些方法能改变字符串。其实这些方法并不是修改字符串对象，而是删除原有字符串，再建立一个新的字符串，所以并没有违背元组的不可变性。



#### 字符串对象方法

下面的示例中，str是一个字符串，sub是str的一个子字符串。s为一个序列，它的元素都是字符串。width为一个整数，用于说明新生成字符串的宽度。

``` python
str = "Hello World!"
sub = "World"
str.count(sub)         #返回：sub在str中出现的次数
str.find(sub)          #返回：从左开始，查找sub在str中第一次出现的位置。
                       #如果str中不包含sub，返回-1
str.index(sub)         #和上面的一样的意思
str.rfind(sub)         #返回：从右开始，查找sub在str中第一次出现的位置。
                       #如果str中不包含sub，举出错误
str.rindex(sub)        #和上面的一样的意思
str.isalnum()          #返回：True，如果所有的字符都是字母或数字
                       #注意上面空格，标点符号也不能出现
str.isalpha()          #返回：True，如果所有的字符都是字母
str.isdigit()          #返回：True，如果所有的字符都是数字
str.istitle()          #返回：True，如果所有的词的首字母都是大写
str.isspace()          #返回：True，如果所有的字符都是空格
str.islower()          #返回:True,如果所有的字符都是小写字母
str.isupper()          #返回：True，如果所有的字符都是大写字母
str.split([sep, [max]]) # 返回：从左开始，以空格为分隔符，
                        # 将str分隔为多个子字符串，总共分隔max次
str.rplit([sep, [max]]) # 返回：从右开始，以空格为分隔符，
                        # 将str分隔为多个子字符串，总共分隔max次
str.joins(s)            # 返回：将s中的元素，以str为分隔符
                        # 合并为一个字符串
```



### 词典对象

词典同样是一个类，我们定义了一个词典对象后，可以充分利用下词典类中的各种方法。



#### 词典对象方法

keys()方法来循环遍历每个元素的键，keys()的方法实现的是把这个词典的所有的key塞到一个list中。

``` python
example_dict = {"a":1, "b":2}
type(example_dict)
for k in example_dict.keys():
    print(example_dict[k])
```



values()方法循环遍历每个元素的值，values()的方法实现的是把这个词典的所有的value塞到一个list中。

``` python
for v in example_dict.values():
    print(v)
```



items()方法直接遍历每个元素：

``` python
for k,v in example_dict.items():
    print(k,v)
```



clean()方法，清空整个词典：

``` python
example_dict.clean()     #清理完后，变成了{}
```



## 意想不到的对象

### 循环对象

在Python中循环数据结构也是由循环对象来实现的。



#### 什么是循环对象

所谓的循环对象包含有一个\_next_()方法。这个方法的目的是生成循环的下一个结果。在生成过循环的所有结果之后，刚方法将抛出StopIteration异常。

例如一个for这样的循环语法调用循环对象时，它会在每次循环的时候调用/_next_()方法，知道StopIteration出现。循环接收到这个异常，就会知道循环已经结束，将停止调用\_next_()。

下面的案例主要验证的是\_next_()方法,内置函数iter()会把一个列表转变为循环对象。在真实的for循环中，我们可以省去内置函数iter的转换。这是因为，for结构会自动执行这一转换。

``` python
example_iter = iter([1,2])
example_iter.__next__()         # 显示1
example_iter.__next__()         # 显示2
example_iter.__next__()         # 出现StopIteration异常

for item in iter([1,2]):
    print(item)

for item in (1,2):
    print(item)
```



#### 生成器

我们同样可以借助于生成器(generator)来自定义循环对象。生成器的编写方法和函数定义类似，只是在return的地方改为yield。

生成器中可以有多个yield。当生成器遇到一个yield时，会暂停运行生成器，返回yield后面的值。当再次调用生成器的时候，会从刚才暂停的地方继续运行，直到下一个yield。生成器自身又构成一个循环对象，每次循环使用一个yield返回的值。Python中的内置函数range()返回的是一个循环对象，而不是一个序列。

``` python
def gen():
    a = 100
    yield a
    a = a*8
    yield a 
    yield 1000

for i in gen():
    print(i)
```



### 函数对象

在Python中，函数也是一种对象。实际上，任何一个有\__call__()特殊方法的对象都被当作是函数。

通过type()方法来查看一个函数的类型，可以看到我们定义的一个函数其实也是一个函数类。我们在调用函数的过程，实际上是初始化了一个函数对象；而调用函数，加入实参的过程，就是对这个函数对象调用了__call__的内置方法，实现了函数传参。

``` python
class SampleMore(object):
    def __call__(self, a):
        return a + 5

add_five = SampleMore()    #生成函数对象
print(add_five(2))         #像一个函数一样调用函数对象，结果为7.

#原先我们定义函数的过程如下；
def call(a):
    return a + 5
print(call(2))
```



### 模块对象

在Python中的模块对应一个.py文件，模块也是对象。在前面的定义中，我们看到在调用模块中各个属性和方法的过程，实际上就是调用对象的属性或方法的过程。



#### 调用模块对象中方法的几种方式

1. 第一种方法，from ... import ...的方式

   ``` python
   from time import sleep    #单独从time模块中引入sleep动态属性
   sleep(10)
   ```

2. 第二种方法，from ... import * 的方式

   ``` python
   from time import *        #使用简单暴力的方法，一次性引入模块的所有属性
   sleep(10)
   ```

3. 第三钟方法，import ... 的方式

   ``` python
   import time               #引入time模块
   time.sleep(10)            #利用对象.属性的方式来调用它
                             #带上对象名的方式，好处可以避免模块中的属性引用时候，
                             #出现同名
   ```

4. 第四种方法，import ... as xxx的方式

   ``` python
   import time as t         #我们还可以给模块换个名字
   t.sleep(10)
   ```

5. 第五种方法，引入文件夹中的模块

   ``` python
   import this_dir.module       #"this_dir"是目录名称,module是模块的名字
                                #模块的名字也就是xxx.py前面的名字
                                #需要在"this_dir"下建立一个__init__.py空文件
   ```



#### 模块对象的名字

每个模块对象都有一个\__name__属性，用来记录模块的名字。

当一个.py文件作为主程序运行的时候，比如python foo.py，这个文件也会有一个对应的模块对象。但这个模块对象的\__name__属性会是   "\__main__"



### 异常对象

我们在程序中加入异常处理的try结构，捕捉程序中出现的异常。

实际上，我们捕捉到的也是一个对象。

利用except ... as ...的语法，我们在except结果中用e来代表捕获到的类型对象。关键字except直接跟随ZeroDivisionError实际上是异常对象的类。

``` python
try:
    m = 1/0
except ZeroDivisionError as e:
    print("Catch NameError in the sub-function")
    print(type(e))        #查看到该异常类的类型
    print(dir(e))         # 异常对象的属性
    print(e.message)      # 打印的异常信息
```



## 对象带你飞

## 存储

### 文件(文本对象)

磁盘以文件为单位来存储数据。

对于计算机来说，**数据的本质就是有序的二进制数序列**。

如果以**字节为单位**，也就是**每8位二进制数序列为单位**，那么这个数据序列就称为文本。

这是因为，8位二进制数序列正好对应ASCII编码中的一个字符。

**而Python能够借助文本对象来读写文件**。



#### 创建文本对象

在Python中，我们可以通过内置函数open来创建文件对象。在调用open的时候，需要说明文件名，以及打开文件的方式。

``` python
f = open(文件名，方式)
"r" #读取已经存在的文件
"w" #新建文件，并写入
"a" #如果文件存在，那么写入到文件的结尾
    #如果文件不存在，则新建文件并写入
```



1. 只读的方式打开文件

   ``` python
   f = open("test.txt", "r")
   ```

2. 读取文件

   ``` python
   content = f.read(10)  #读取10个字节的数据
   content = f.readline() #读取一行
   content = f.readlines() #读取所有行，存储在列表中，每个元素都是一行
   ```

3. 写或追加方式打开文件

   ``` python
   f = open("test.txt", "w")
   f = open("test.txt", "a")
   ```

4. 写入文件

   ``` python
   f.write("I like apple")
   f.write("I like apple\n")    #Unix系统中加入换行符
   f.write("I like apple\r\n")    #windows系统中加入换行符
   ```

5. 关闭文件

   ``` python
   打开文件端口将占用计算机资源，因此，
   在读写完成后，应该及时用文件对象的close方法关闭文件：
   f.close()
   ```



### 上下文管理器

文件操作常常和上下文管理器一起使用。



#### 什么是上下文管理器

上下文管理器(context manager)用于规定某个对象的使用范围。一旦进入或离开该使用范围，则会有特殊操作被调用，比如为对象分配或者释放内存。



#### 为什么需要上下文管理器

对于文件操作，我们需要在读写结束时关闭文件。我们经常会忘记关闭文件，无谓的占用资源。上下文管理器可以在不需要文件的时候，自动关闭文件。



#### 如何使用上下文管理器

下面有两个案例，一个案例是常规的文件操作，一个案例是使用上下文管理器的方式来进行的文件操作。

第二段程序就使用了with...as...的结构。上下文管理器有隶属于它的程序块，当隶属的程序块执行结束时，也就是语句不再缩进时，上下文管理器就会自动关闭文件。在程序中，我们使用f.closed属性来验证是否已经关闭。通过上下午管理器，我们相当于用缩进来表达对象的打开范围。

``` python
# 常规使用
f = open("new.txt","w")
print(f.closed)               # 检查文件是否打开
f.write("Hello World!")
f.close()
print(f.closed)               # 打印true

# 使用上下文管理器
with open("new.txt","w") as f:
    f.write("Hello World!")
print(f.closed)
```



### pickle包

#### pickle包是用来干什么的

从文字的理解来看，该模块是用来把某个对象保存下来，再存在磁盘里的文件。

使用pickle包中的dump()或dumps()方法来进行序列化。

使用pickle包中的load()方法进行反序列化



#### 为什么需要pickle包(序列化和反序列化)

序列化:将变量从内存中变成可以存储或传输的过程称之为序列化，在Python中叫做pickling，在其它语言中也称之为 serialization、marshaling、flattening等等，说的都是一个意思。

反序列化：反之，则为反序列化，称之为unpickling，把变量内容从序列化的对象重新读取到内存中。



#### 为什么需要序列化

不序列化时，对象存储存在的问题：

比如：我要将对象写入一个磁盘文件而后再将其读出来会有什么问题吗？别急，其中一个最大的问题就是对象引用！
举个例子来说：假如我有两个类，分别是A和B，B类中含有一个指向A类对象的引用，现在我们对两个类进行实例化{ A a = new A(); B b = new B(); }。
这时在内存中实际上分配了两个空间，一个存储对象a，一个存储对象b。
接下来我们想将它们写入到磁盘的一个文件中去，就在写入文件时出现了问题！因为对象b包含对对象a的引用，所以系统会自动的将a的数据复制一份到b中，这样的话当我们从文件中恢复对象时(也就是重新加载到内存中)时，内存分配了三个空间，而对象a同时在内存中存在两份，想一想后果吧，如果我想修改对象a的数据的话，那不是还要搜索它的每一份拷贝来达到对象数据的一致性，这不是我们所希望的！

序列化的解决方案：

1. 保存到磁盘的所有对象都获得一个序列号(1, 2, 3等等)
2. 当要保存一个对象时，先检查该对象是否被保存了
3. 如果以前保存过，只需写入"与已经保存的具有序列号x的对象相同"的标记，否则，保存该对象通过以上的步骤序列化机制解决了对象引用的问题！

> https://blog.csdn.net/qq_37160773/article/details/95060070
>
> https://blog.csdn.net/u011215133/article/details/51177843



#### 保存对象到文件

下面有2个示例，一个普通的例子。分别为创建对象、序列化对象、字节文本的存储。

第二个示例，是上面的例子的简化。

``` python
# 第一种示例
import pickle
class Bird(object):
    have_feather = True
    reprodution_method = "egg"
summer = Bird()                       #创建对象
pickle_string = pickle.dumps(summer)  #序列化对象

with open("summer.pkl", "wb") as f:
    f.write(pickle_string)
# 第二种示例
import pickle
class Bird(object):
    have_feather = True
    reprodution_method = "egg"
summer = Bird()
with open("summer.pkl", "w") as f:
    pickle.dump(summer, f)
```



#### 从文件读取对象

读取对象与存储对象的过程正好相反。首先，我们从文件中读出文本。然后使用pickle的loads()方法，将字符串形式的文本转换为对象。也可以使用pickle中的load()方法，将上面两步合并。

有时候，仅仅是反向恢复还不够。对象依赖于它的类，所以Python在创建对象时，需要找到相应的类。

所以，当我们从文本中读取对象的时候，程序中必须已经定义过类。对于Python总是存在的内置类，如列表、词典、字符串等，不需要再在程序中定义。但对于用于自定义的类，就必须要先定义类，然后才能从文件中载入该类的对象。

``` python
import pickle
class Bird(object):
    have_feather = True
    reproduction_method = "egg"
with open("summer.pkl", "rb") as f:
    summer = pickle.load(f)
print(summer.have_feather)               # 打印True
```



## 时间类的包

挂钟时间：

在硬件的基础上，计算机可以提供**挂钟时间**(Wall Clock Time)。挂钟时间是从某个固定时间起点到现在的时间间隔。对于Uninx系统来说，起点时间是1970年1月1日的0点0分0秒。其他的日志信息都是从挂钟时间计算得到的。

处理器时间：

计算机还可以测量CPU实际运行的时间，也就是**处理器时间**(Processor Clock Time)，以测量计算机性能。当CPU处于闲置状态的时候，处理器时间会暂停。



### time包

1. time()方法

   time包中的time()方法，显示挂钟时间。
   
   ``` python
   import time
   print(time.time())  # 挂钟时间，单位是秒
   ```

2. clock()方法

   time包中的clock()用来测量程序运行的时间，在程序中两次调用clock()方法，从而测量出镶嵌其间的程序所用的时间。**在不同的计算机系统上，clock()的返回值会有所不同。在Unix系统上，返回的是处理器时间。当CPU处于闲置状态时，处理器时间会暂停。因此，我们获取的是CPU运行时间。在Windows系统上，返回的则是挂钟时间**。
   
   ``` python
   import time
   start = time.clock()
   for i in range(1000000):
       print(i**2)
   end = time.clock()
   print(end - start)
   ```

3. sleep()方法

   sleep()方法可以让程序休眠。根据sleep()接收到的参数，程序会在某时间间隔之后醒来继续运行。

   ``` python
   import time
   print("start")
   time.sleep(10)    # 休眠10秒
   print("wake up")
   ```

4. stuct_time对象

   time包中还定义了stuct_time对象。该对象将挂钟时间转换为年、月、日、时、分、秒等，存储在该对象的各个属性中，比如tm_year、tm_mon、tm_mday .... 下面几种方法可以将挂钟时间转换为struct_time对象。

   ``` python
   st = time.gmtime()     # 返回struct_time格式的UTC时间
   st = time.localtim()   # 返回struct_time格式的当地时间，
                          # 当地时区根据系统环境设定
   ```

   也可以把一个stuct_time对象转换为time对象：

   ``` python
   s = time.mktime(st)    # 将struct_time格式转换成挂钟时间
   ```



### datetime包

#### 什么是datetime模块

datetime包是基于time包的一个高级包，用起来更加便利。datetime可以理解为由date和time两个部分组成。date是年月日，time是时、分、秒、毫秒。



#### 如何使用datetime模块

datetime模块下面有两个类：**datetime.date类和datetime.time类**。如果要想得到年月日是分秒，可以直接调用**datetime.datetime类**。

显示时间：该对象t有时、分、秒、年、月、日等属性

``` python
import datetime
t  = datetime.datetime(2012,9,3,21,30)
print(t)
t2 = datetime.datetime.now()    # 显示当前时间
print(t2)
```

时间间隔计算：

在datetime包中，有个专门代表时间间隔对象的类，即stimedelta。

在一个datetime.datetime的时间点加上一个时间间隔，就可以得到一个新的时间点。

datetime.timedelta传递参数时，除了秒和星期外，还可以是天、小时、毫秒、微妙。

``` python
import datetime
t        = datetime.datetime(2012,9,3,21,30)
t_next   = datetime.datetime(2012,5,3,23,30)
delta1   = datetime.timedelta(seconds = 600)
delta2   = datetime.timedelta(weeks = 3)
print(t + delta1)        
print(t + delta2)
print(t_next - t)
```

datetime对象比较：

两个datetime对象进行比较运算，以确定哪个时间间隔更长。

``` python
print(t > t_next)          # 打印False
```



### 日期格式

这里特意强调在datetime模块中日期格式的问题，主要是为了说明下面的日期格式转换。例如用strptime的方法实现日期的字符串转换为datetime的对象；用strftime方法实现把datetime对象转换为日期的字符串。

``` python
from datetime import datetime
str        = "output-1997-12-23-030000.txt"
format     = "output-%Y-%m-%d-%H%M%S.txt"
t          = datetime.strptime(str, format)
print(t) 

from datetime import datetime
format = "%Y-%m-%d %H:%M"
t = datetime(2012,9,5,23,30)
print(t.strftime(format))
```



## 正则表达式

### 什么是正则表达式

正则表达式的主要功能是从**字符串**中通过**特定的模式**，搜索希望找到的内容。

这个功能有点和字符串对象中的搜索查找的方法，但是**字符串对象中的查找是指，从一个大的字符串中，找出一个子字符串**。而我们这里的使用正则表达式的目的在于，只是想要找到符合某种格式的字符串，而不是具体的那个子字符串。



### 如何使用正则表达式

#### 从字符串中找出相应子字符串

``` python
import re
m      = re.search("[0-9]", "dfsd789ddsfad")
print(m.group(0))
```

re.search()接收两个参数，第一个参数"[0-9]"就是我们所说的正则表达式，告诉Python去从第二个字符串中找出从0到9的任意一个数字字符。

re.search()中的第二个参数，是指需要去查找的那个字符串。整体而言，就是从后面的字符串中，找出符合要求的子字符串，就返回一个对象m。可以通过m.group()的方法查看搜索到的结果。如果没有找到符合要求的字符，则re.search()会返回None.

归纳为如下的使用模式：

``` python
m = re.search(pattern, string) # 搜索整个字符串，直到发现符合的子字符串
```



#### 从字符串中匹配相应的正则表达式

下面的使用方式是指，从头开始检查字符串是否符合正则表达式。

必须从字符串的第一个字符开始就相符。

``` python
m = re.match(pattern, string)
```



#### 替换符合正则规则的字符串

下面的sub()利用正则pattern在字符串string中进行搜索，对于搜索到的字符串，用另一个字符串replacement进行替换。函数将返回替换后的字符串。

``` python
str = re.sub(pattern, replacement, string)
```



#### 根据正则分隔字符串

下面的用法是，根据正则表达式来分割字符串，将分割后的所有子字符串放在一个表(list)中返回。

``` python
re.split()
```



#### 根据正则返回所有子字符串

根据正则表达式搜索字符串，将所有符合条件的子字符串放在一个表(list)中返回。

``` python
re.findall()
```



### 正则表达式有哪些

1. 用某些符号代表单个字符
2. 用某些符合代表某种形式的重复
3. 位置相关的符号



### 利用group来查看正则表达搜索结果

有时候，我们想要查看匹配到的正则表达式的那个具体的，符合正则表达式的部分结果。我们可以在正则表达式上给目标加上括号。

用括号()圈起来的正则表达式的一部分，称为群。一个正则表达式中可以有多个群。

我们可以用group(number)的方法来查询群。需要注意的是，group(0)是整个正则表达式的搜索结果。group(1)是第一个群，以此类推。

``` python
import re
m = re.search("output_(\d{4})", "output_1986.txt")
print(m.group(1))     # 将找到4个数字组成的1896
```



### 给group命名

我们还可以将群命名，以便更好地使用group查询：

下面的(?P\<year>...)括住一个群，并把它命名为year。用这种方式来产生群，就可以通过"year"这个键来提取结果了。

``` python
import re
m = re.search("output_(?P<year>\d{4})", "output_1986.txt")
print(m.group("year"))
```



## Python的网络访问

### HTTP通信简介

HTTP的request请求信息如下：

``` python
GET /index.html  HTTP/1.1
Host: www.example.com
```

起始行中，有三段信息：

* GET方法，用于说明想要服务器执行的操作。
* /index.html资源的路径。这里指向服务器上的index.html文件
* HTTP/1.1协议的版本。

HTTP的response回复信息如下：

``` python
HTTP/1.1 200 OK
Content-type: text/plain
Content-length: 12
    
Helllo World!
```

* HTTP/1.1：协议版本
* 200：状态码(status code)
* OK：状态描述
* Content-type说明了主体所包含的资源的类型，有普通文件，HTML文本，jpeg图片等。
* Content-length说明了主体部分的长度，以字节(byte)为单位。



### http.client包

http.client包(模块)中，包含了很多的http的方法，我们可以利用这些方法来实现http的通信。

从上面的http请求中看出，在HTTP请求中最重要的一些信息是主机信息、请求方法和资源路径。

``` python
import http.client
conn     = http.client.HTTPConnection("www.example.com")  #主机地址
conn.request("GET", "/")  #请求方法和资源路径
response = conn.getresponse()  # 获得回复
print(response.status, response.reason)  # 回复的状态码和状态描述
content =  response.read()      # 回复的主体内容
print(content)
```



## 与对象的深入交往

在本章的前半部分，介绍了**运算符、元素引用、内置函数**，这些其实都是来自于一些特殊的对象。这样的设计既满足了Python的多范式的需求，又能以简单的体系满足丰富的语法需求，如运算符重载与即时特性等。

本章的后半部分，将深入了解对象相关的重要机制，如**动态类型和垃圾回收**。



## 一切皆对象

### 运算符

我们常见的运算符，比如+、-、>、<、and、or等，都是通过特殊方法实现的。或者说是通过归属类中的定义的相应的内置方法来实现的。

在子类中重新定义了相应的运算符的方法后，子类中的方法会覆盖父类的同名发你规范。即运算符将被重新定义。

我们以list列表类为例，如果我们用dir(list)查看list的属性，能看到一个属性时\__add__()是特殊方法。**这个方法定义了"+"运算符对于list对象的意义**，两个list的对象相加时，会进行合并列表的操作。

+号，对应的类中的方法是: "\__add__()"

-号，对应的类中的方法是: "\__sub__()"

*号，对应的类中的方法是: "\__mul__()"

or号，对应的类中的方法是："\__or__()"

定义运算符对于复杂的对象非常有用。例如，人类有多个属性，比如姓名、年龄和身高。我们可以把人类的比较(>、<、=)定义成只看年龄。



### 元素引用

序列包含的一个数据被称为序列的一个**元素**。

序列是有顺序的数据集合，就好像一列排好队的士兵。序列分为元组和列表两种。

我的理解是这里的"元素引用"是指，在序列(元组或列表)或词典中，单独对其中的一个元素，进行方法的运算。

下面的案例中，展示了元素的获取的方法，更新的方法、删除的方法。

``` python
li    = [1, 2, 3, 4, 5, 6]
print(li[3])
print(li.__getitem__(3))     # 获取元素
li.__setitem__(3,0)          # 更新元素
print(li)

example_dict   = {"a":1, "b":2}
example_dict.__delitem__("a")    # 删除元素
print(example_dict)
```



### 内置函数的实现

与运算符类似，许多内置函数也都是调用对象的特殊方法。

例如，下面的例子中的\__len__()方法，实际上和执行内置函数len()一样的作用，起到了简化的作用。

``` python
len([1,2,3])
[1,2,3].__len__()
```



## 属性管理

### 属性覆盖的背后

当我们调用对象的属性的时候，这个属性可能有很多来源。除了来自对象属性和类属性，这个属性还可能是从祖先类那里继承来的。

一个类或对象拥有的属性，会记录在\__dict__中。这个\__dict__是一个词典，键为属性名，对应的值为某个属性。Python在寻找对象的属性的时候，会按照继承关系依次寻找__dict__。

这个顺序是按照与summer对象的亲近关系排列的。

我们用内置函数dir来查看对象summmer的属性的话，可以看到summer对象包含了全部四个部分。也就是说，对象的属性时分层管理的。对象summer能接触到的所有属性，分别存在summer/Chicken/Bird/object这四层。当我们需要调用某个属性的时候，Python会一层层向下遍历，直到找到那个属性。由于对象不需要重复存储其祖先类的属性，所以分层管理的机制可以节省存储空间。

某个属性可能在不同层被重复定义。Python在向下遍历的过程中，会选取先遇到的那一个。这正是属性覆盖的原理。

但是如果是进行赋值，那么Python就不会分层深入查找了。



### 特性

同一个对象的不同属性之间可能存在依赖关系。当某个属性被修改时，我们希望依赖于该属性的其他属性也同时变化。

这时，我们不能通过\__dict__的静态词典方式来存储属性。Python提供了多种即时生成属性的方法。其中一种称为**特性(property)**。特性是特殊的属性。

特性使用内置函数property()来创建。property()最多可以加载四个参数。前三个参数为函数，分别用于设置获取、修改和删除特性时，Python应该执行的操作。最后一个参数为特性的文档，可以为一个字符串，起说明作用。

下面的案例中，num为一个数字，而neg为一个特性，用来表示数字的负数。当一个数字确定的时候，它的负数总是确定的。而当我们修改了一个数的负数的时候，它本身的值也应该变化。这两点由get_neg()和set_neg()来实现。而del_neg()

``` python
class num(object):
    def __init__(self, value):
        self.value = value
    def get_neg(self):
        return -self.value
    def set_neg(self, value):
        self.value = -value
    def del_neg(self):
        print("value also deleted")
        del self.value
    neg = property(get_neg, set_neg, del_neg, "I am negative")

x = num(1.1)
print(x.neg)

x.neg = -22 
print(x.value)
print(num.neg.__doc__)
del x.neg
```



### \__getattr__()方法

除了内置函数property外，还可以使用\__gettr__(self,name)来查询即时生成的属性。

当我们调用对象的一个属性的时候，如果通过\__dict__机制无法找到该属性，那么Python就会调用对象的\__getattr__()方法，来即时生成该属性。

和上面property特性的区别：

每个特性都需要有自己的处理函数，而\__getatr__()可以将所有的即时生成属性放在同一个函数中处理。而\__getattr__()可以根据函数名来区别处理不同的属性。

\__getattr__()只能用于查询不在\__dict__系统中的属性。

\__setattr__(self,name,value)和  \__delattr__(self,name)可用于修改和删除属性。



## 我是风儿，我是沙

### 动态类型

Python的变量不需要声明，在赋值的时候，变量可以重新赋值为其他任意值。

Python变量这种变化的能力，就是动态类型的体现。



#### 对象名是指向对象的一个引用

在下面的例子```a =1```说明了，在Python中，整数1是一个对象。对象的名字是"a"，对象名其实是指向对象的一个引用。对象是存储在内存中的实体。我们必须使用对象名，来执行这一对象的"引用"。

通过内置函数id()，能查看到引用指向的是哪个对象。

``` python
a = 1
print(id(1))
print(id(a))
```



#### 变量名重新赋值

在Python中，赋值其实就是用对象名这个筷子去夹住其他的食物。**每次赋值，我们让左侧的引用指向右侧的对象**。引用能随时指向一个新的对象。

下面的例子中，3是存储在内存中的一个整数对象。通过赋值，引用a指向对象3。这时建立了一个字符串对象"at"，通过赋值，我们将引用a指向"at"。

既然变量名是个随时可以变更指向的引用，那么它的类型自然可以在程序中动态变化。

``` python
a = 3
print(id(a))
a = "at"
print(id(a))
```



#### 判断两个引用是否指向同一个对象

除了直接打印id外，我们还可以用is运算来判断两个引用是否指向同一个对象。

``` python
a    = 3
b    = 3
print(a is b)
```



### 可变与不可变对象

不可变对象：

意思是该对象，通过不同的变量名进行引用后，如果我们对引用后的变量名进行运算，不会改变原有的对象的值或内容，这就叫做是不可变对象。一般有：**列表、词典**。

可变对象：

意思是该对象，通过不同的变量名进行引用后，如果我们对引用后的变量名进行运算，结果改变了原有的对象的值或内容，这就叫做是可变对象。一般有：**整数、浮点数、字符串、元组等**。



### 从动态类型引用角度看函数的参数传递

函数的参数传递，本质上传递的是引用。每个参数或变量都是一个引用，当我们调用函数的时候，函数需要的形参，实际上通过引用的方式来指向实际的对象的值。

下面的例子，分别从可变对象和不可变对象两个例子来说明：

``` python
def f(x):
    print(id(x))
    x = 100
    print(id(x))
a = 1
print(id(a))
f(a)
print(a)

def f(x):
    x[0] = 100
    print(x)
a = [1, 2, 3]
f(a)
print(a)
```



## 内存管理

### 引用管理

对象内存管理是**基于对引用的管理**。在Python中，引用与对象是分离的。

一个对象可以有多个引用，而每个对象中都存有指向该对象的引用总数，即**引用计数**。我们可以使用标准库中sys包中的getrefcount()，来查看某个对象的引用计数。

注意下面的例子中，我们想要查看对[1, 2, 3]这个列表对象的引用次数。这里我们使用了某个引用作为参数，传递给了getrefcount()时，参数实际上是创建了一个临时的引用。

``` python
from sys import getrefcount
a = [1, 2, 3]
print(getrefcount(a))
b = a
print(getrefcount(b))
```



### 对象引用对象

容器对象的引用可能会构成很复杂的拓扑结构。我们可以用objgraph包来绘制其引用关系。

两个对象可能相互引用，从而构成所谓的**引用环**。

引用环会给垃圾回收机制带来很大的麻烦。

我们可以通过del关键字删除某个引用，或者当这个引用被重新定向到某个其他对象时，也会减少对象的引用。



### 垃圾回收

#### 为什么需要垃圾回收

当Python中的对象越来越多的时候，它们将占用越来越大的内存。Python会在适当的时候启动垃圾回收，将没用的对象清除。



#### 什么是垃圾回收

原理上，当Python的某个对象的引用计数降为0，即没有任何引用指向该对象的时候，该对象就称为要回收的垃圾了。

垃圾回收费时费力，当垃圾回收的时候，Python不能进行其他的任务。频繁的垃圾回收将大大降低Python的工作效率。

如果内存中的对象不多，就没有必要频繁启动垃圾回收。所以，Python只会在特定条件下，自动启动垃圾回收。当Python运行时，会记录其中分配对象(Object Allocation)和取消分配对象(Object Deallocation)的次数。当两者的差值高于某个阀值的时候，垃圾回收才会启动。



#### Python分代回收策略

下面的700的阀值，是基础回收方式。除了基础回收方式外，Python同时还采用了分代回收的策略。

这一策略的基本假设是，**存活时间越久的对象，越不可能在后面的程序中变成垃圾**。我们程序往往会产生大量的对象，许多对象很快产生和消失，但也有一些对象长期被使用。出于信任和效率，对于这样一些"长寿"对象，我们相信它们还有用处，所以减少在垃圾回收中扫描它们的频率。

Python将所有的对象分为0、1、2三代。所有的新建对象都是0代对象。当某一代对象经历过垃圾回收，依然存活，那么它就被归入下一代对象。垃圾回收启动时，一定会扫描所有的0代对象。如果0代经过一定次数垃圾回收，那么就启动对0代和1代的扫描清理。当1代也经历了一定次数的垃圾回收后，就会启动对0、1、2代的扫描，即对所有对象进行扫描。



#### 如何配置垃圾回收

我们可以通过gc模块的get_threshold()方法，来查看该阀值。一般返回的是(700,10,10)

``` python
import gc
print(gc.get_threshold())
```

700即垃圾回收启动的阀值。可以通过gc中的set_threshold()方法重新设置。也可以手动使用gc.collect()来手动启动垃圾回收。

后面两个10，与分代回收相关的阀值。也就是说，每10次0代垃圾回收，会配合1次1代的垃圾回收；而每10次1代的垃圾回收，才会有1次2代的垃圾回收。

可以使用set_threshold()来调整次数，比如下面对2代对象进行更频繁的扫描。

``` python
import gc
gc.set_threshold(700, 10, 5)
```



### 孤立的引用环

引用环的存在会给垃圾回收机制带来很大的困难。这些引用环可能构成无法使用，但引用计数不为0的一些对象。

在下面的例子中，由于引用环的存在，这两个对象的引用计数都没有降到0，所以不会被垃圾回收。

``` python
a = []
b = [a]
a.append(b)
del a
del b
```

为了回收这样的引用环，Python会复制每个对象的引用计数，可以记为gc_ref。假设，每个对象i，该计数为gc_ref_i。Python会遍历所有的对象i。对于每个对象i所引用的对象j，将相应的gc_ref_j减去1。

在结束遍历后，gc_ref不为0的对象，和这些对象引用的对象，以及继续更下游引用的对象，需要被保留，而其他对象则被垃圾回收。



## 函数式编程

Python虽然不是纯粹的函数式编程，但是包含了不少函数式编程的语法。

面向过程编程中，利用选择和循环结构，以及函数、模块等，对指令进行封装。

面向对象编程中，实现了另外一种形式的封装，包含有数据的对象的一系列方法，这些方法能造成对象的状态改变。

面向函数编程中，本质上也在于以函数为中心进行代码封装。



## 又见函数

### Python中的函数式

Python中的函数实际上是一些特殊的对象。这一条已经符合函数式编程的一个重要方面：函数是第一级对象，能像普通对象一样使用。



#### 函数式编程中函数纯粹性

函数式编程强调了函数的纯粹性。一个纯函数是没有副作用的，即这个函数的运行不会影响其他函数。纯函数像一个沙盒，把函数带来的效果控制在内部，从而不影响程序的其他部分。

为了达到纯函数的标准，函数式编程要求其变量都是不可变更的。



#### Python与函数式编程

Python并非完全的函数式编程语言。在Python中借鉴了函数式编程，尽量在编程中避免副作用。函数式编程的好处在于：纯函数相互独立，不会相互影响；纯函数方便进行并行化运算。

早期的Python版本中，并没有函数式编程的相关语法。后来Python中加入了lambda函数，以及map、filter、reduce等高阶函数，从而加入了函数式编程的特征。

函数式编程的思维方式，是自上而下的。它先提出一个大问题，在最高层用一个函数来解决这个大问题。在这个函数内部，再用其他函数来解决小问题。在这样递归式的分解下，直到问题得到解决。



#### 消除竞跑条件

在下面的案例中，当多个进行同时修改一个变量的时候，进程的先后顺序会影响最终结果。

下面的两个函数中使用了关键字global。global说明了x是一个全局变量。函数对全局变量的修改能被其他函数看到，因此有副作用。函数的执行顺序不确定，最终结果也不一定。这就被称为**竞跑条件**,是并行编程中需要极力避免的。

``` python
from threading import Thread
x = 5
def double():
    global x
    x = x * 2
def plus_ten():
    global x
    x = x + 10
thread1 = Thread(target=double)
thread2 = Thread(target=plus_ten)
thread1.start()
thread2.start()
thread1.join()
thread2.join()
print(x)
```



### 并行运算

#### 什么是串行运算

一台单处理器的计算机同一时间内只能执行一条指令。这种每次执行一条指令的工作方式称为串行运算。



#### 什么是并行运算

所谓的并行运算，是指多条指令同时执行。我们可以在单机上通过多进程或多线程的方式，来模拟多主机的并行处理。

事实上，单机的处理器按照"分时复用"的方式，把运算能力分配给多个进程。处理器在进程间频繁切换。因此，即使处理器同一时间只能处理一个指令，但通过在进程间的切换，也能造成多个进程齐头并进的效果。



#### 进程与线程

进程有自己的内存空间，用来存储自身的运行状态、数据和相关代码。

一个进程一般不会直接读取其他进程的内存空间。进程运行过程中，可以完成程序描述的工作。但在一个进程内部，又可以有多个称为"线程"的任务，处理器可以在多个线程之间切换，从而形成并行的多线程处理。

线程看起来和进程类似，但是线程之前可以共享同一个进程的内存空间。



#### 多进程编程案例

在下面的案例中是个多进程编程的例子。程序用了两个进程，进程的工作包含在函数中，分别是函数proc1()和函数proc2()。方法start()用于启动进程，而join()方法用于在主程序中等待相应进程完成。



## 被解放的函数

### 函数作为参数

在函数式编程中，函数是第一级对象。所谓"第一级对象"，即函数能像普通对象一样使用。

函数可以像一个普通对象一样，成为其他函数的参数。和称为其他函数的返回值。

在下面的程序中，函数就充当了参数。函数argument_demo()的第一个参数f就是一个函数对象。**按照位置传参，square_sum()传递给函数argument_demo()，对应参数列表中的f**。

``` python
def square_sum(a, b):
    return a**2 + b**2
def cubic_sum(a, b):
    return a**3 + b**3
def argument_demo(f, a, b):
    return f(a, b)
print(argument_demo(square_sum, 3, 5))
print(argument_demo(cubic_sum, 3, 5))
```



### 函数作为返回值

既然函数是一个对象，那么它就**可以成为另一个函数的返回结果**。

下面的line_conf()函数的返回结果被赋予line对象，看到了在一个函数内部定义的函数。

``` python
def line_conf():
    def line(x):
        return 2*x+1
    return line
my_line = line_conf()   # 函数对象
print(my_line(5))
```



#### 函数对象作用域

和函数内部的对象一样，函数对象也有存活范围，也就是函数对象的作用域。Python的缩进形式很容易让我们看到函数对象的作用域。

下面的例子中，我们在line_conf()函数的隶属范围内定义的函数line()，就只能在line_conf()的隶属范围内调用。超出了函数line()的作用域，Python对该函数的调用失败。

``` python
def line_conf():
    def line(x):
        return 2*x + 1
    print(line(5))          # 作用域内
if __name__=="__main__":
    line_conf()
    print(line(5))          # 作用域外，报错
```



### 闭包

#### 什么是闭包

一个函数和它的环境变量合在一起，就构成了一个闭包。

在Python中，**所谓的闭包是一个包含有环境变量取值的函数对象**。首先**闭包是一个函数对象**，另外这个函数对象有些特殊，里面包含了环境变量取值。

环境变量取值被复制到函数对象的\__closure__属性中。在下面的案例中，my_line()的 __closure__属性中**包含了一个元组**。这个元组中的**每个元素都是cell类型的对象**。第一个cell包含的就是整数5，也就是我们返回闭包时的环境变量b的取值。

``` python
def line_conf():
    b = 15
    def line(x):
        return 2*x + b
    b = 5
    return line      # 返回函数对象
if __name__ == "__main__":
    my_line = line_conf()
    print(my_line.__closure__)
    print(my_line.__closure__[0].cell_contents)
```



#### 为什么需要闭包

提高了代码的可复用性。从下面的例子中，函数line()与环境变量a、b构成闭包。在创建闭包的时候，我们通过line_conf()的参数a、b说明直线的参量。

这样，我们就能复用同一个闭包，通过代入不同的数据来获得不同的直线函数，如y=x+1和y=4x+5。**闭包实际上创建了一群形式相似的函数**。

``` python
def line_conf(a, b):
    def line(x):
        return a*x + b
    return line

line1 = line_conf(1, 1)
line2 = line_conf(4, 5)
line3 = line_conf(5, 10)
line4 = line_conf(-2, -6)
```



使用闭包，还可以起到减少函数参数的作用：

下面的例子中，函数curve()是一个二次函数。它除了自变量x外，还有a、b、c三个参数。**通过curve_closure()这个闭包，我们可以预设a、b、c三个参数的值。从而起到减少参数的作用**。

``` python
def curve_closure(a, b, c):
    def curve(x):
        return a*x**2 + b*x + c
    return curve
curve1 = curve_closure(1, 2, 1)
```



## 小女子的梳妆匣

### 装饰器

#### 什么是装饰器

装饰器是一种高级Python的语法。装饰器可以对**一个函数、方法或者类**进行加工。装饰器从操作上入手，为函数增加额外的指令。

在Python中的变量名和对象是分离的，变量名其实是指向一个对象的引用。**从本质上，装饰器起到的作用就是名称绑定，让同一个变量名指向一个新返回的函数对象，从而达到修改函数对象的目的**。

只不过，我们很少彻底地更改函数对象。在使用装饰器时，我们往往会在新函数内部调用旧的函数，以便保留旧函数的功能。

函数装饰器是，接收一个函数，并返回一个函数，从而起到加工函数的效果。



#### 为什么需要装饰器

在下面的例子中，我们想要为函数增加其他的功能，比如打印输入。我们重新修改函数的定义，为函数增加了功能。但是也可以改用装饰器，定义功能拓展本身，再把装饰器用于两个函数。

``` python
def decorator_demo(old_function):
    def new_function(a, b):
        print("input", a, b)
        return old_function(a, b)
    return new_function


@decorator_demo
def square_sum(a, b):
    return a**2 + b**2

@decorator_demo
def square_diff(a, b):
    return a**2 - b**2

if __name__ == "__main__":
    print(square_sum(3, 4))
    print(square_diff(3, 4))
```



#### 如何使用装饰器

在上面的例子中，装饰器可以用def的形式定义，如上面代码中的decorator_demo()。**装饰器可以接受一个可调用对象作为输入参数，并返回一个新的可调用对象**。

装饰器新建了一个函数对象，也就是上面的new_function()。在new_function()中，我们增加了打印的功能，并通过old_function(a,b)来保留原有函数的功能。

定义好装饰器后，我们就可以通过@语法使用了。在函数square_sum()和square_diff()定义之前调用@decorator_demo，实际上就是将square_sum()或square_diff()传递给了decorator_demo()，并将decorator_demo()返回的新的函数对象赋给原来的函数名square_sum()和square_diff()。

所以当我们调用squre_sum(3,4)的时候，实际上发生的是：

``` python
square_sum = decorator_demo(square_sum)
square_sum(3,4)
```



#### time包装饰器

在下面的案例中，我们利用time包来测量程序运行的时间。**把测量程序运行时间的功能做成一个装饰器，将这个装饰器运用于其他函数，将显示函数的实际运行时间**。

在new_function()中，除了调用旧函数外，还前后额外调用了一次time.time()。由于time.time()返回挂钟时间，它们的差值反映了旧函数的运行时间。此外，我们通过打包参数的办法，可以在新函数和旧函数之间传递所有的参数。



#### 装饰器的其他好处

装饰器可以实现代码的可复用性。我们可以用同一个装饰器修饰多个函数，以便实现相同的附加功能。例如，我们在每次处理HTTP请求前，都想附加一个客户验证功能时，那么就可以定义一个统一的装饰器，作用于每一个处理函数。



### 带参装饰器

#### 什么是带参装饰器

下面的例子中pre_str是一个带参装饰器。它实际上是对原有装饰器的一个函数封装，并返回一个装饰器。我们可以将它理解为一个含有环境参数的闭包。

当我们使用@pre_str("^_^")调用的时候，Python能够发现这一层的封装，并把参数传递到装饰器的环境中。

该调用相当于：```square_sum = pre_str("^_^")(square_sum)```

``` python
def pre_str(pre=""):
    def decorator(old_function):
        def new_function(a, b):
            print(pre + "input", a, b)
            return old_function(a, b)
        return new_function
    return decorator

@pre_str("^_^")
def square_sum(a, b):
    return a**2 + b**2 

@pre_str("T_T")
def square_diff(a, b):
    return a**2 - b**2

if __name__ == "__main__":
    print(square_sum(3, 4))
    print(square_diff(3, 4))
```



#### 带参装饰器的好处

根据参数不同，带参装饰器会对函数进行不同的加工，进一步提高了装饰器的适用范围。我们可以把"管理员"和"用户"作为参数，传递给验证装饰器。

对于那些负责关键HTTP请求的函数，我们可以把"管理员"参数传给装饰器。

对于那些负责普通HTTP请求的函数，我们可以把"用户"参数传给它们的装饰器。

这样，同一个装饰器就可以满足不同的需求了。



### 装饰类

#### 什么是装饰类

和函数的装饰器的概念比较类似，在类的装饰器中，一个装饰器可以接收一个类，并返回一个类，从而起到加工类的效果。

无论是装饰函数，还是装饰类，装饰器的核心作用都是名称绑定。



#### 如何使用装饰器

在下面的案例中，我们在装饰器decorator_class中，返回了一个新类NewClass。在新类的构造器中，我们用一个属性self.wrapped记录了原来类生成的对象，并附加了新的属性total_display，用于记录调用display()的次数。我们同时更改了display方法。通过装饰，我们的Bird类可以显示调用display()的次数。

``` python
def decorator_class(SomeClass):
    class NewClass(object):
        def __init__(self, age):
            self.total_display = 0
            self.wrapped = SomeClass(age)
        def display(self):
            self.total_display +=1
            print("total display", self.total_display)
            self.wrapped.display()
    return NewClass


@decorator_class
class Bird:
    def __init__(self, age):
        self.age = age
    def display(self):
        print("My age is", self.age)

if __name__ == "__main__":
    eagle_lord = Bird(5)
    for i in range(3):
        eagle_lord.display()
```



## 高阶函数

什么是高阶函数？

能接收其他函数作为参数的函数，被称为高阶函数。

高阶函数是函数式编程的一个重要组成部分。

本节我们讲解最具有代表性的高阶函数：map()、filter()和reduce()。



### lambda与map

#### 什么是lambda表达式

这是一种新的定义函数的方式，之前我们定义函数的方式都是使用def关键字。



#### 为什么需要lambda表达式

通过lambda表达式，我们可以创建一个匿名的函数对象。

通常的def定义函数的方式，比较繁琐，有时候我们不需要来定义函数的名称。



#### 如何使用lambda表达式

在下面的例子中，我们实现的是定义个函数，实现两个参数的和的功能。通过lambda表达式，我们可以创建一个匿名的函数对象。借着赋值语句，这个匿名函数赋予给函数名lambda_sum。

函数的参数为x、y，返回值为x与y的和。函数lambda_sum()的调用与正常函数一样。这种lambda来产生匿名函数的方式适用于简短函数的定义。

``` python
def sum(x, y):
    return x+y
改为lambda表达式
lambda_sum = lambda x, y: x + y
print(lambda_sum(3, 5))
```



#### map函数

所谓高阶函数，就是能处理函数的函数。

map()是Python的内置函数，它的第一个参数就是一个函数对象；map()的第二个参数是一个可循环对象。对于data_list的每个元素，lambda函数都会调用一次。

那个元素会成为lambda函数的参数。换个角度说，map()把接收到的函数对象依次作用于每一个元素。最终，map()会返回一个迭代器。迭代器中的元素，就是多次调用lambda函数的结果。

``` python
def equivalent_generator(func, iter):
    for item in iter:
        yield func(item)
data_list = [1,3,5,6]
result =  map(lambda x: x+3, data_list)
```



map()的多参数函数：

可以定义多个参数，这个时候，map()的参数列表中就需要提供相应数目的可循环对象。

下面的案例中，map()接收了square_sum()作为第一个参数。square_sum()要求有两个参数。因此，map()调用的时候需要两个可循环对象。第一个循环对象提供了square_sum()中对应于x的参数，第二个循环对象提供了对应于y的参数。

``` python
def square_sum(x, y):
    return x**2 + y**2
data_list1 = [1,3,5,7]
data_list2 = [2,4,6,8]
result = map(square_sum, data_list1, data_list2)
```



### filter函数

map()函数和filter()函数的功能有很多相似的地方，都是把同一个函数应用于多个数据。

和map()函数一样，**内置函数filter()的第一个参数也是一个函数对象**。它也**将这个函数对象作用于可循环对象的多个元素**。如果函数对象返回的是True，则该次的元素被放到返回的迭代器中。也就是说，filter()通过调用函数来筛选数据。

类似的，filter()用于多参数的函数时，也可以在参数中增加更多的可循环对象。

下面的案例中，使用的是filter()函数的一个例子。作为参数的larger100()函数用于判断元素是否比100大。

``` python
def larger1(a):
    if a > 100:
        return True
    else:
        return False
for item in filter(larger100, [10, 56, 101, 500]):
    print(item)
```



### reduce函数

#### 什么是reduce函数

reduce()函数是一个常见的高阶函数。函数reduce()在标准库的functools包中，使用之前需要引入。

和map()、reduce()一样，reduce()函数的第一个参数是函数，**但是reduce()对作为参数的函数对象有一个特殊要求，就是这个作为参数的函数必须能接收两个参数**。

reduce()可以把函数对象累进的作用于各个参数。



#### 如何使用reduce函数

在下面的案例中，reduce()函数的第一个参数是求和的sum()函数，它接收两个参数x和y。在功能上，reduce()累进的运用传给它的二参函数。上一次运算的结构将作为下一次调用的第一个参数。上面过程不断重复，直到列表中的元素耗尽。

``` python
from functools import reduce
data_list = [1,2,5,7,9]
result =  reduce(lambda x,y: x + y, data_list)
print(result)
```



#### map&reduce 并行运算

函数reduce()通过某种形式的二元运算，把多个元素收集起来，形成一个单一的结果。map()函数和reduce()函数都是单线程的，所以运行效果和循环差不多。

但map()、reduce()可以方便地移植到并行化的运行环境中。在并行运算中，reduce运算紧接着map运算。map运算的结果分布在多个主机上，reduce运算把结果收集起来。



### 并行处理



## 自上而下

### 便携表达式

函数式变的思维是自上而下式的。Python中也有不少体现了这一思维的语法，如生成器表达式、列表解析和词典解析。



#### 生成器表达式

生成器表达式是构建生成器的便捷方法。

下面的例子分别是用原有的方式用生成器定义循环对象，和用生成器表达式来定义循环对象。

``` python
def gen():
    for i in range(4):
        yield i
等价使用：
gen = (x for x in range(4))
```



#### 列表解析

利用列表解析的方式是快速生成列表的方法。

列表解析的语法和生成器的表达式很像，只不过把小括号换成了中括号。

语法直观，直截了当地说明了想要的是元素的平方，然后再通过for来增加限定条件，即哪些元素的平方。

``` python
l = []
for x in range(10):
    l.append(x**2)
等价使用：
l = [x**2 for x in range(10)]
```



#### 词典解析

词典解析可用于快捷的生成词典。它的语法也与之前的类似：

``` python
d = {k: v for k,v in enumerate("Vamei") if val not in "Vi"}
```



### 懒惰求值

Python中的迭代器的工作方式正是函数式编程中的**懒惰求值**。我们可以对迭代器进行各种各样的操作。

懒惰求值可以最小化计算机要做的工作。

除了运算资源，懒惰求值还能节约内存空间。对于即时求值来说，其运算过程的中间结果都需要占用不少额内存空间。而懒惰求值可以现在迭代器层面上进行操作，在获得最终迭代器以后一次性完成计算。



### itertools包

标准库中的itertools包提供了更加灵活的生成迭代器的工具，这些工具的输入大都是以后的迭代器。另一方面，这些工具完全可以自行使用Python实现，该包只是提供了一种比较标准、高效的实现方式。

